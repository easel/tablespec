"""Expectation Guide Utilities - Helper functions for validation prompt generation.

This module provides utilities for loading expectation categories, parameter requirements,
and formatting expectation documentation for LLM prompts.
"""

import json
from pathlib import Path
from typing import Any, Literal

# Cache for loaded JSON files
_CATEGORIES_CACHE: dict[str, Any] | None = None
_PARAMETERS_CACHE: dict[str, Any] | None = None


def _get_schemas_dir() -> Path:
    """Get path to schemas directory."""
    return Path(__file__).parent.parent / "schemas"


def load_expectation_categories() -> dict[str, Any]:
    """Load expectation categories from JSON file.

    Returns
    -------
        Dictionary with categories: baseline_only, llm_table_level, llm_column_level, etc.

    """
    global _CATEGORIES_CACHE
    if _CATEGORIES_CACHE is None:
        categories_path = _get_schemas_dir() / "expectation_categories.json"
        with categories_path.open() as f:
            _CATEGORIES_CACHE = json.load(f)
    assert _CATEGORIES_CACHE is not None
    return _CATEGORIES_CACHE


def load_expectation_parameters() -> dict[str, Any]:
    """Load expectation parameter requirements from JSON file.

    Returns
    -------
        Dictionary with parameter specs for each expectation type

    """
    global _PARAMETERS_CACHE
    if _PARAMETERS_CACHE is None:
        parameters_path = _get_schemas_dir() / "expectation_parameters.json"
        with parameters_path.open() as f:
            _PARAMETERS_CACHE = json.load(f)
    assert _PARAMETERS_CACHE is not None
    return _PARAMETERS_CACHE


def get_llm_generatable_expectations(
    context: Literal["table", "column"] = "table",
) -> list[str]:
    """Get list of expectations appropriate for LLM generation in given context.

    Args:
    ----
        context: Either 'table' (multi-column, cross-column) or 'column' (single-column)

    Returns:
    -------
        List of expectation type names suitable for LLM generation

    """
    categories = load_expectation_categories()

    if context == "table":
        # Table-level + pending fallback
        expectations = (
            categories["llm_table_level"]["expectations"]
            + categories["pending_fallback"]["expectations"]
        )
    elif context == "column":
        # Column-level + pending fallback
        expectations = (
            categories["llm_column_level"]["expectations"]
            + categories["pending_fallback"]["expectations"]
        )
    else:
        msg = f"Invalid context: {context}. Must be 'table' or 'column'"
        raise ValueError(msg)

    return expectations


def get_baseline_only_expectations() -> list[str]:
    """Get list of expectations that should ONLY be generated by baseline generator.

    Returns
    -------
        List of baseline-only expectation type names

    """
    categories = load_expectation_categories()
    return categories["baseline_only"]["expectations"]


def get_parameter_requirements(expectation_type: str) -> dict[str, Any] | None:
    """Get parameter requirements for a specific expectation type.

    Args:
    ----
        expectation_type: Name of the expectation (e.g., 'expect_column_values_to_be_in_set')

    Returns:
    -------
        Dictionary with required_kwargs, optional_kwargs, examples, etc., or None if not found

    """
    parameters = load_expectation_parameters()

    # Check in each category
    for category_key in [
        "table_level_expectations",
        "column_level_expectations",
        "pending_fallback",
    ]:
        if category_key in parameters and expectation_type in parameters[category_key]:
            return parameters[category_key][expectation_type]

    return None


def format_expectation_list(
    expectations: list[str],
    include_descriptions: bool = False,
) -> str:
    """Format list of expectations for display in prompt.

    Args:
    ----
        expectations: List of expectation type names
        include_descriptions: Whether to include parameter descriptions

    Returns:
    -------
        Formatted string with expectation list

    """
    if not include_descriptions:
        # Simple bullet list
        return "\n".join(f"- {exp}" for exp in expectations)

    # Include parameter details
    load_expectation_parameters()
    lines = []

    for exp in expectations:
        lines.append(f"**{exp}**")

        # Get parameter info
        param_info = get_parameter_requirements(exp)
        if param_info:
            required = param_info.get("required_kwargs", [])
            optional = param_info.get("optional_kwargs", [])

            if required:
                lines.append(f"  - Required: {', '.join(f'`{k}`' for k in required)}")
            if optional:
                lines.append(f"  - Optional: {', '.join(f'`{k}`' for k in optional)}")

            # Add notes if present
            if "notes" in param_info:
                lines.append(f"  - Note: {param_info['notes']}")

        lines.append("")  # Blank line

    return "\n".join(lines)


def format_parameter_details(expectation_type: str) -> str:
    """Format detailed parameter documentation for a specific expectation.

    Args:
    ----
        expectation_type: Name of the expectation

    Returns:
    -------
        Formatted string with parameter details, examples, and common mistakes

    """
    param_info = get_parameter_requirements(expectation_type)
    if not param_info:
        return f"No parameter information available for {expectation_type}"

    lines = [f"## {expectation_type}\n"]

    # Required kwargs
    required = param_info.get("required_kwargs", [])
    if required:
        lines.append("**Required kwargs:**")
        for kwarg in required:
            param_details = param_info.get("parameter_details", {}).get(kwarg, {})
            param_type = param_details.get("type", "unknown")
            description = param_details.get("description", "")
            lines.append(f"- `{kwarg}` ({param_type}): {description}")
        lines.append("")

    # Optional kwargs
    optional = param_info.get("optional_kwargs", [])
    if optional:
        lines.append("**Optional kwargs:**")
        for kwarg in optional:
            param_details = param_info.get("parameter_details", {}).get(kwarg, {})
            param_type = param_details.get("type", "unknown")
            description = param_details.get("description", "")
            lines.append(f"- `{kwarg}` ({param_type}): {description}")
        lines.append("")

    # Example
    if "example" in param_info:
        lines.append("**Example:**")
        lines.append("```json")
        lines.append(json.dumps(param_info["example"], indent=2))
        lines.append("```")
        lines.append("")

    # Common mistakes
    if "common_mistakes" in param_info:
        lines.append("**Common mistakes to avoid:**")
        for mistake in param_info["common_mistakes"]:
            lines.append(f"- {mistake}")
        lines.append("")

    # Notes
    if "notes" in param_info:
        lines.append(f"**Note:** {param_info['notes']}")
        lines.append("")

    return "\n".join(lines)


def get_pending_decision_tree() -> str:
    """Get formatted decision tree for when to use expect_validation_rule_pending_implementation.

    Returns
    -------
        Formatted decision tree string

    """
    parameters = load_expectation_parameters()
    pending_info = parameters["pending_fallback"][
        "expect_validation_rule_pending_implementation"
    ]

    lines = [
        "## When to Use expect_validation_rule_pending_implementation",
        "",
        "Use this fallback expectation when validation requirements cannot be mapped to ",
        "standard Great Expectations expectations. This marks rules for future human implementation.",
        "",
        "**Use pending implementation when:**",
    ]

    when_to_use = pending_info.get("when_to_use", [])
    for reason in when_to_use:
        lines.append(f"- {reason}")

    lines.extend(
        [
            "",
            "**Required meta fields:**",
            "- `description` (string, REQUIRED): Comprehensive description of what needs to be validated and why",
            "- `severity` (string, REQUIRED): Use 'info' or 'warning' (NOT 'critical')",
            "",
            "**Recommended meta fields:**",
            "- `reason_unmappable` (string): Why this cannot be mapped to standard GX",
            "- `suggested_implementation` (string): How this could be implemented (e.g., custom expectation, UDF)",
            "",
            "**Example:**",
            "```json",
        ]
    )

    example = pending_info.get("example", {})
    lines.append(json.dumps(example, indent=2))
    lines.append("```")

    return "\n".join(lines)


def format_quick_reference(context: Literal["table", "column"] = "table") -> str:
    """Format a quick reference guide of LLM-generatable expectations.

    Args:
    ----
        context: Either 'table' or 'column'

    Returns:
    -------
        Formatted quick reference string

    """
    expectations = get_llm_generatable_expectations(context)

    lines = [f"## {context.title()}-Level Expectations - Quick Reference\n"]

    for exp in expectations:
        param_info = get_parameter_requirements(exp)
        if not param_info:
            continue

        # Show expectation name + required kwargs
        required = param_info.get("required_kwargs", [])
        if required:
            kwargs_str = ", ".join(f"`{k}`" for k in required)
            lines.append(f"**{exp}** (requires: {kwargs_str})")
        else:
            lines.append(f"**{exp}**")

        # Show brief description from notes or parameter_details
        notes = param_info.get("notes", "")
        if notes:
            lines.append(f"  {notes}")

        lines.append("")

    return "\n".join(lines)


def validate_expectation_against_schema(
    expectation: dict[str, Any],
) -> tuple[bool, list[str]]:
    """Validate that an expectation has required parameters.

    Args:
    ----
        expectation: Expectation dictionary with 'type', 'kwargs', 'meta'

    Returns:
    -------
        Tuple of (is_valid, list_of_errors)

    """
    errors = []

    exp_type = expectation.get("type")
    if not exp_type:
        errors.append("Missing required field 'type'")
        return False, errors

    kwargs = expectation.get("kwargs", {})
    if not isinstance(kwargs, dict):
        errors.append("Field 'kwargs' must be a dictionary")
        return False, errors

    # Get parameter requirements
    param_info = get_parameter_requirements(exp_type)
    if not param_info:
        # Unknown expectation type (might be baseline-only)
        baseline_expectations = get_baseline_only_expectations()
        if exp_type in baseline_expectations:
            errors.append(
                f"Expectation '{exp_type}' is baseline-only and should not be generated by LLM"
            )
        return len(errors) == 0, errors

    # Check required kwargs
    required_kwargs = param_info.get("required_kwargs", [])
    for req_kwarg in required_kwargs:
        if req_kwarg not in kwargs:
            errors.append(f"Missing required kwarg '{req_kwarg}' for {exp_type}")

    # Check meta fields (especially for pending implementation)
    if exp_type == "expect_validation_rule_pending_implementation":
        meta = expectation.get("meta", {})
        if "description" not in meta:
            errors.append(
                "Pending implementation expectation missing required meta.description"
            )
        if "severity" not in meta:
            errors.append(
                "Pending implementation expectation missing required meta.severity"
            )

    return len(errors) == 0, errors
